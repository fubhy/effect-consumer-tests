import * as Cause from "../../Cause.js";
import type * as Channel from "../../Channel.js";
import type * as ChildExecutorDecision from "../../ChildExecutorDecision.js";
import type * as Context from "../../Context.js";
import * as Effect from "../../Effect.js";
import * as Exit from "../../Exit.js";
import * as Option from "../../Option.js";
import type * as UpstreamPullStrategy from "../../UpstreamPullStrategy.js";
import * as core from "../core-stream.js";
import * as ChannelState from "./channelState.js";
import * as Continuation from "./continuation.js";
import * as Subexecutor from "./subexecutor.js";
export type ErasedChannel<R> = Channel.Channel<R, unknown, unknown, unknown, unknown, unknown, unknown>;
export declare class ChannelExecutor<Env, InErr, InElem, InDone, OutErr, OutElem, OutDone> {
    private _activeSubexecutor;
    private _cancelled;
    private _closeLastSubstream;
    private _currentChannel;
    private _done;
    private _doneStack;
    private _emitted;
    private _executeCloseLastSubstream;
    private _input;
    private _inProgressFinalizer;
    private _providedEnv;
    constructor(initialChannel: Channel.Channel<Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>, providedEnv: Context.Context<unknown> | undefined, executeCloseLastSubstream: (effect: Effect.Effect<Env, never, unknown>) => Effect.Effect<Env, never, unknown>);
    run(): ChannelState.ChannelState<Env, unknown>;
    getDone(): Exit.Exit<OutErr, OutDone>;
    getEmit(): OutElem;
    cancelWith(exit: Exit.Exit<OutErr, OutDone>): void;
    clearInProgressFinalizer(): void;
    storeInProgressFinalizer(finalizer: Effect.Effect<Env, never, unknown> | undefined): void;
    popAllFinalizers(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, never, unknown>;
    popNextFinalizers(): Array<Continuation.ContinuationFinalizer<Env, unknown, unknown>>;
    restorePipe(exit: Exit.Exit<unknown, unknown>, prev: ErasedExecutor<Env> | undefined): Effect.Effect<Env, never, unknown> | undefined;
    close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, never, unknown> | undefined;
    doneSucceed(value: unknown): ChannelState.ChannelState<Env, unknown> | undefined;
    doneHalt(cause: Cause.Cause<unknown>): ChannelState.ChannelState<Env, unknown> | undefined;
    processCancellation(): ChannelState.ChannelState<Env, unknown>;
    runBracketOut(bracketOut: core.BracketOut): ChannelState.ChannelState<Env, unknown>;
    provide(effect: Effect.Effect<unknown, unknown, unknown>): Effect.Effect<unknown, unknown, unknown>;
    runEnsuring(ensuring: core.Ensuring): void;
    addFinalizer(f: ErasedFinalizer<Env>): void;
    runSubexecutor(): ChannelState.ChannelState<Env, unknown> | undefined;
    replaceSubexecutor(nextSubExec: Subexecutor.Subexecutor<Env>): void;
    finishWithExit(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, unknown, unknown>;
    finishSubexecutorWithCloseEffect(subexecutorDone: Exit.Exit<unknown, unknown>, ...closeFuncs: Array<(exit: Exit.Exit<unknown, unknown>) => Effect.Effect<Env, never, unknown> | undefined>): ChannelState.ChannelState<Env, unknown> | undefined;
    applyUpstreamPullStrategy(upstreamFinished: boolean, queue: ReadonlyArray<Subexecutor.PullFromChild<Env> | undefined>, strategy: UpstreamPullStrategy.UpstreamPullStrategy<unknown>): readonly [Option.Option<unknown>, ReadonlyArray<Subexecutor.PullFromChild<Env> | undefined>];
    pullFromChild(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, onEmitted: (emitted: unknown) => ChildExecutorDecision.ChildExecutorDecision, subexecutor: Subexecutor.PullFromChild<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    finishWithDoneValue(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, doneValue: unknown): void;
    handleSubexecutorFailure(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, cause: Cause.Cause<unknown>): ChannelState.ChannelState<Env, unknown> | undefined;
    pullFromUpstream(subexecutor: Subexecutor.PullFromUpstream<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    performPullFromUpstream(subexecutor: Subexecutor.PullFromUpstream<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    drainChildExecutors(subexecutor: Subexecutor.DrainChildExecutors<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
}
//# sourceMappingURL=channelExecutor.d.ts.map